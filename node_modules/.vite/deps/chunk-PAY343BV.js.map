{
  "version": 3,
  "sources": ["../../@mui/utils/esm/setRef/setRef.js", "../../@mui/utils/esm/useForkRef/useForkRef.js"],
  "sourcesContent": ["/**\n * TODO v5: consider making it private\n *\n * passes {value} to {ref}\n *\n * WARNING: Be sure to only call this inside a callback that is passed as a ref.\n * Otherwise, make sure to cleanup the previous {ref} if it changes. See\n * https://github.com/mui/material-ui/issues/13539\n *\n * Useful if you want to expose the ref of an inner component to the public API\n * while still using it inside the component.\n * @param ref A ref callback or ref object. If anything falsy, this is a no-op.\n */\nexport default function setRef(ref, value) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n}", "'use client';\n\nimport * as React from 'react';\nimport setRef from '../setRef';\nexport default function useForkRef(...refs) {\n  /**\n   * This will create a new function if the refs passed to this hook change and are all defined.\n   * This means react will call the old forkRef with `null` and the new forkRef\n   * with the ref. Cleanup naturally emerges from this behavior.\n   */\n  return React.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n    return instance => {\n      refs.forEach(ref => {\n        setRef(ref, instance);\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}"],
  "mappings": ";;;;;;;;AAae,SAAR,OAAwB,KAAK,OAAO;AACzC,MAAI,OAAO,QAAQ,YAAY;AAC7B,QAAI,KAAK;AAAA,EACX,WAAW,KAAK;AACd,QAAI,UAAU;AAAA,EAChB;AACF;;;ACjBA,YAAuB;AAER,SAAR,cAA+B,MAAM;AAM1C,SAAa,cAAQ,MAAM;AACzB,QAAI,KAAK,MAAM,SAAO,OAAO,IAAI,GAAG;AAClC,aAAO;AAAA,IACT;AACA,WAAO,cAAY;AACjB,WAAK,QAAQ,SAAO;AAClB,eAAO,KAAK,QAAQ;AAAA,MACtB,CAAC;AAAA,IACH;AAAA,EAEF,GAAG,IAAI;AACT;",
  "names": []
}
